(()=>{"use strict";var e={949:(e,r)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.CheckWebGPU=void 0,r.CheckWebGPU=()=>{let e="Great, your current browser supports WebGPU!";return navigator.gpu||(e='Your current browser does not support WebGPU! Make sure you are on a system \n            with WebGPU enabled. Currently, WebGPU is supported in  \n            <a href="https://www.google.com/chrome/canary/">Chrome canary</a>\n            with the flag "enable-unsafe-webgpu" enabled. See the \n            <a href="https://github.com/gpuweb/gpuweb/wiki/Implementation-Status"> \n            Implementation Status</a> page for more details.   \n            You can also use your regular Chrome to try a pre-release version of WebGPU via\n            <a href="https://developer.chrome.com/origintrials/#/view_trial/118219490218475521">Origin Trial</a>.                \n           '),e}},519:function(e,r,t){var n=this&&this.__awaiter||function(e,r,t,n){return new(t||(t=Promise))((function(o,a){function u(e){try{s(n.next(e))}catch(e){a(e)}}function i(e){try{s(n.throw(e))}catch(e){a(e)}}function s(e){var r;e.done?o(e.value):(r=e.value,r instanceof t?r:new t((function(e){e(r)}))).then(u,i)}s((n=n.apply(e,r||[])).next())}))},o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(r,"__esModule",{value:!0});const a=t(949),u=o(t(508));n(void 0,void 0,void 0,(function*(){var e;const r=a.CheckWebGPU();if(r.includes("Your current browser does not support WebGPU!"))throw console.log(r),"Your current browser does not support WebGPU!";const t=document.getElementById("canvas-webgpu"),n=yield null===(e=navigator.gpu)||void 0===e?void 0:e.requestAdapter(),o=yield null==n?void 0:n.requestDevice(),i=t.getContext("webgpu"),s="bgra8unorm";i.configure({device:o,format:s});const c=o.createRenderPipeline({vertex:{module:o.createShaderModule({code:u.default}),entryPoint:"vs_main"},fragment:{module:o.createShaderModule({code:u.default}),entryPoint:"fs_main",targets:[{format:s}]},primitive:{topology:"triangle-list"}}),l=o.createCommandEncoder(),d=i.getCurrentTexture().createView(),v=l.beginRenderPass({colorAttachments:[{view:d,loadValue:{r:.2,g:.247,b:.314,a:1},storeOp:"store"}]});v.setPipeline(c),v.draw(3,1,0,0),v.endPass(),o.queue.submit([l.finish()])}))},508:(e,r,t)=>{t.r(r),t.d(r,{default:()=>n});const n="// vertex shader\r\n\r\nstruct Output {\r\n    @builtin(position) Position : vec4<f32>;\r\n    @location(0) vColor : vec4<f32>;\r\n};\r\n\r\n@stage(vertex)\r\nfn vs_main(@builtin(vertex_index) VertexIndex: u32) -> Output {\r\n    var pos = array<vec2<f32>, 3>(\r\n        vec2<f32>(0.0, 0.5),\r\n        vec2<f32>(-0.5, -0.5),\r\n        vec2<f32>(0.5, -0.5)\r\n    );\r\n\r\n    var color = array<vec3<f32>, 3>(\r\n        vec3<f32>(1.0, 0.0, 0.0),\r\n        vec3<f32>(0.0, 1.0, 0.0),\r\n        vec3<f32>(0.0, 0.0, 1.0)\r\n    );\r\n\r\n    var output: Output;\r\n    output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\r\n    output.vColor = vec4<f32>(color[VertexIndex], 1.0);\r\n    return output;\r\n}\r\n\r\n// fragment shader\r\n\r\n@stage(fragment)\r\nfn fs_main(@location(0) vColor: vec4<f32>) -> @location(0) vec4<f32> {\r\n    return vColor;\r\n}"}},r={};function t(n){var o=r[n];if(void 0!==o)return o.exports;var a=r[n]={exports:{}};return e[n].call(a.exports,a,a.exports,t),a.exports}t.d=(e,r)=>{for(var n in r)t.o(r,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:r[n]})},t.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r),t.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t(519)})();
//# sourceMappingURL=main.bundle.js.map