(()=>{"use strict";var e={949:(e,n)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.CheckWebGPU=void 0,n.CheckWebGPU=()=>{let e="Great, your current browser supports WebGPU!";return navigator.gpu||(e='Your current browser does not support WebGPU! Make sure you are on a system \n                     with WebGPU enabled. Currently, SPIR-WebGPU is only supported in  \n                     <a href="https://www.google.com/chrome/canary/">Chrome canary</a>\n                     with the flag "enable-unsafe-webgpu" enabled. See the \n                     <a href="https://github.com/gpuweb/gpuweb/wiki/Implementation-Status"> \n                     Implementation Status</a> page for more details.                   \n                    '),e}},519:function(e,n,t){var r=this&&this.__awaiter||function(e,n,t,r){return new(t||(t=Promise))((function(o,a){function i(e){try{u(r.next(e))}catch(e){a(e)}}function c(e){try{u(r.throw(e))}catch(e){a(e)}}function u(e){var n;e.done?o(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(i,c)}u((r=r.apply(e,n||[])).next())}))};Object.defineProperty(n,"__esModule",{value:!0});const o=t(949),a=t(708);r(void 0,void 0,void 0,(function*(){var e;const n=o.CheckWebGPU();if(n.includes("Your current browser does not support WebGPU!"))throw console.log(n),"Your current browser does not support WebGPU!";const t=document.getElementById("canvas-webgpu"),r=yield null===(e=navigator.gpu)||void 0===e?void 0:e.requestAdapter(),i=yield null==r?void 0:r.requestDevice(),c="bgra8unorm",u=t.getContext("gpupresent").configureSwapChain({device:i,format:c}),v=a.Shaders(),s=i.createRenderPipeline({vertex:{module:i.createShaderModule({code:v.vertex}),entryPoint:"main"},fragment:{module:i.createShaderModule({code:v.fragment}),entryPoint:"main",targets:[{format:c}]},primitive:{topology:"triangle-list"}}),f=i.createCommandEncoder(),l=u.getCurrentTexture().createView(),d=f.beginRenderPass({colorAttachments:[{view:l,loadValue:[.5,.5,.8,1],storeOp:"store"}]});d.setPipeline(s),d.draw(3,1,0,0),d.endPass(),i.queue.submit([f.finish()])}))},708:(e,n)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.ShadersOld=n.Shaders1=n.Shaders=void 0,n.Shaders=()=>({vertex:"\n        struct Output {\n            [[builtin(position)]] Position : vec4<f32>;\n            [[location(0)]] vColor : vec4<f32>;\n        };\n\n        [[stage(vertex)]]\n        fn main([[builtin(vertex_index)]] VertexIndex: u32) -> Output {\n            var pos = array<vec2<f32>, 3>(\n                vec2<f32>(0.0, 0.5),\n                vec2<f32>(-0.5, -0.5),\n                vec2<f32>(0.5, -0.5)\n            );\n    \n            var color = array<vec3<f32>, 3>(\n                vec3<f32>(1.0, 0.0, 0.0),\n                vec3<f32>(0.0, 1.0, 0.0),\n                vec3<f32>(0.0, 0.0, 1.0)\n            );\n\n            var output: Output;\n            output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n            output.vColor = vec4<f32>(color[VertexIndex], 1.0);\n            return output;\n        }\n    ",fragment:"\n        [[stage(fragment)]]\n        fn main([[location(0)]] vColor: vec4<f32>) -> [[location(0)]] vec4<f32> {\n            return vColor;\n        }\n    "}),n.Shaders1=()=>({vertex:"\n        let pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n            vec2<f32>(0.0, 0.5),\n            vec2<f32>(-0.5, -0.5),\n            vec2<f32>(0.5, -0.5)\n        );\n\n        let color : array<vec3<f32>, 3> = array<vec3<f32>, 3>(\n            vec3<f32>(1.0, 0.0, 0.0),\n            vec3<f32>(0.0, 1.0, 0.0),\n            vec3<f32>(0.0, 0.0, 1.0)\n        );\n\n        struct Output {\n            [[builtin(position)]] Position : vec4<f32>;\n            [[location(0)]] vColor : vec4<f32>;\n        };\n\n        [[stage(vertex)]]\n        fn main([[builtin(vertex_index)]] VertexIndex: u32) -> Output {\n            var output: Output;\n            output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n            output.vColor = vec4<f32>(color[VertexIndex], 1.0);\n            return output;\n        }\n    ",fragment:"\n        [[stage(fragment)]]\n        fn main([[location(0)]] vColor: vec4<f32>) -> [[location(0)]] vec4<f32> {\n            return vColor;\n        }\n    "}),n.ShadersOld=()=>({vertex:"\n        const pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n            vec2<f32>(0.0, 0.5),\n            vec2<f32>(-0.5, -0.5),\n            vec2<f32>(0.5, -0.5)\n        );\n\n        const color : array<vec3<f32>, 3> = array<vec3<f32>, 3>(\n            vec3<f32>(1.0, 0.0, 0.0),\n            vec3<f32>(0.0, 1.0, 0.0),\n            vec3<f32>(0.0, 0.0, 1.0)\n        );\n\n        [[builtin(position)]] var<out> Position : vec4<f32>;\n        [[builtin(vertex_idx)]] var<in> VertexIndex : i32;\n        [[location(0)]] var<out> vColor : vec4<f32>;\n\n        [[stage(vertex)]]\n        fn main() -> void {\n            Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n            vColor = vec4<f32>(color[VertexIndex], 1.0);\n            return;\n        }\n    ",fragment:"\n        [[location(0)]] var<in> vColor : vec4<f32>;\n        [[location(0)]] var<out> fragColor : vec4<f32>;\n\n        [[stage(fragment)]]\n        fn main() -> void {\n            fragColor = vColor;\n            return;\n        }\n    "})}},n={};!function t(r){var o=n[r];if(void 0!==o)return o.exports;var a=n[r]={exports:{}};return e[r].call(a.exports,a,a.exports,t),a.exports}(519)})();
//# sourceMappingURL=main.bundle.js.map